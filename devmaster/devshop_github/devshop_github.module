<?php

define('GITHUB_POST_RECIEVE_PATH', 'git/post-receive');

/**
 * Implementation of hook_perm()
 */
function devshop_github_perm() {
  return array(
    'allow GitHub WebHooks',
  );
}

/**
 * Implementation of hook_menu()
 */
function devshop_github_menu() {

   $items[GITHUB_POST_RECIEVE_PATH] = array(
    'page callback' => 'devshop_github_post_receive_webhook',
    'access callback' => TRUE,
  );

  return ($items);
}

/*
 * Callback that is invoked by GitHub WebHook facility to create
 * a code pull task.
 */
function devshop_github_post_receive_webhook($platform, $hash) {

  if (strlen($platform) < 1 || strlen($hash) != 32) {
    print "bad parrms";
    return;
  }

  $nid = db_result(db_query(
    "SELECT nid FROM {hosting_context} WHERE name = '%s'", $platform));

  if (!$node = node_load($nid)) {
    print "node_load failed";
    return;
  }

 if (_devshop_github_hash_create($node) != $hash) {
   print "hash check failed";
   return;
 }

 print_r($node);

}

/*
 * Create the full URL that is displayed in the platform node view
 * and given to the GitHub WebHook to invoke a pull after a commit.
 */
function _devshop_github_post_receive_url($node) {
  return url(GITHUB_POST_RECIEVE_PATH .
	'/' . $node->hosting_name .
	'/' . _devshop_github_hash_create($node), 
	array('absolute' => TRUE));
}

/*
 * Create a security hash code based on the platform node
 */
function _devshop_github_hash_create($node) {
  return md5($node->hosting_name . $node->nid);
}

/**
 * hook_nodeapi()
 */
function devshop_github_nodeapi(&$node, $op, $a3 = null) {
  if ($node->type == 'platform') {
    switch ($op) {
      case 'view':
        if (!$a3) { //!teaser
          $node->content['info']['github_webhook'] = array(
            '#type' => 'item',
            '#title' => t('GitHub WebHook URLGitHub WebHook UR'),
            '#weight' => 30,
            '#value' => t(_devshop_github_post_receive_url($node)),
          );
        }
        break;
     }
  }
}
