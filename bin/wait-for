#!/usr/bin/env bash
##
# wait-for.sh
#
# @author Jon Pugh
#
# Runs any command over and over again until it passes, hiding all output but printing a character every time it runs.
#
# Use Environment variables for options:
#
# SLEEP: Length of time to wait in-between running the command.
# CHAR: The character to print after every command run.
# OUTPUT: Set to 'all' to print all output, set to 'out' to print just stdOut, set to "err" to print just stdErr.
#
set -e
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
PATH="$DIR:$PATH"

# All Arguments and options after `wait`
COMMAND=$@

# Environment Variables
SLEEP=${SLEEP:-1}
CHAR=${CHAR:-.}
OUTPUT=${OUTPUT:-}
TIMEOUT=${TIMEOUT:-30}

if [ -z "${COMMAND}" ]; then
  echo "Usage: wait-for any-command-that-exits --until-successful"
  exit 1
fi

log() {
  echo "DevShop | wait-for | $@";
}

runCommand() {

    # If $OUTPUT=out, hide errors.
    if [ "${OUTPUT}" == "out" ]; then
      $COMMAND 2> /dev/null

    # If $OUTPUT=err, print only errors
    elif [ "${OUTPUT}" == "err" ]; then
      $COMMAND > /dev/null

    # If $OUTPUT=all, just print
    elif [ "${OUTPUT}" == "all" ]; then
      $COMMAND

    # Otherwise, hide output and errors
    else
      $COMMAND > /dev/null 2>&1
    fi
}

log "Waiting for command to exit successfully: $COMMAND"

while ! (runCommand)
do
    # Exit with an error if timeout is reached.
    [ "$SECONDS" -gt "$TIMEOUT" ] && echo "Timeout exceeded. Command did not succeed in $SECONDS seconds." && exit 1

    # Pause for $SLEEP seconds.
    sleep $SLEEP

    # Print $CHAR without a new line.
    echo -n "$CHAR"
done

log "Done in $SECONDS seconds!"
